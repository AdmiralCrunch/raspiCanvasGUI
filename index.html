<html lang="en" class=""><head>
    <script src="https://static.codepen.io/assets/editor/live/console_runner-1df7d3399bdc1f40995a35209755dcfd8c7547da127f6469fd81e5fba982f6af.js"></script><script src="https://static.codepen.io/assets/editor/live/css_reload-5619dc0905a68b2e6298901de54f73cefe4e079f65a75406858d92924b4938bf.js"></script><meta charset="UTF-8"><meta name="robots" content="noindex"><link rel="shortcut icon" type="image/x-icon" href="https://static.codepen.io/assets/favicon/favicon-8ea04875e70c4b0bb41da869e81236e54394d63638a1ef12fa558a4a835f1164.ico"><link rel="mask-icon" type="" href="https://static.codepen.io/assets/favicon/logo-pin-f2d2b6d2c61838f7e76325261b7195c27224080bc099486ddd6dccb469b8e8e6.svg" color="#111"><link rel="canonical" href="https://codepen.io/jhnsnc/pen/KXYayG">

    <style >
    
    html, body {
      width: 100%;
      height: 100%;
    }
    
    body {
      padding: 1px;
      background: radial-gradient(#1a1d22, #121318);
    }
    
    .defs {
      position: absolute;
      width: 0;
      height: 0;
      opacity: 0;
    }
    
    .fl-studio-envelope {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 600px;
      padding: 20px;
      overflow: hidden;
      background: #363c40;
      border: 2px solid #272d31;
      box-shadow: 0 10px 70px rgba(0, 0, 0, 0.6);
      -webkit-transform: translate(-50%, -50%);
              transform: translate(-50%, -50%);
    }
    
    .fl-studio-envelope__visualizer {
      height: 200px;
      background: #21272b;
      border: 2px solid #191f23;
    }
    .fl-studio-envelope__visualizer .envelope-visualizer {
      width: 100%;
      height: 100%;
      overflow: visible;
    }
    
    .fl-studio-envelope__controls, .fl-studio-envelope__tension {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .fl-studio-envelope__controls {
      padding: 30px 0 0;
    }
    
    .fl-studio-envelope__control {
      flex: 1 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .fl-studio-envelope__label {
      flex: 0 0 auto;
      display: inline-block;
      padding: 10px 0;
      width: 80px;
      color: #c1c5c5;
      font-size: 10px;
      font-family: 'Helvetica', sans-serif;
      font-weight: 700;
      text-align: center;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .fl-studio-envelope__knob {
      flex: 0 0 auto;
    }
    .fl-studio-envelope__knob.envelope-knob {
      width: 80px;
      height: 80px;
    }
    .fl-studio-envelope__knob.tension-knob {
      padding: 10px;
      width: 80px;
      height: 80px;
    }
    .fl-studio-envelope__knob .knob-input__visual {
      overflow: visible;
    }
    .fl-studio-envelope__knob .dial {
      -webkit-transform-origin: 20px 20px;
              transform-origin: 20px 20px;
      transition: all 600ms cubic-bezier(0.39, 0.575, 0.565, 1);
    }
    .fl-studio-envelope__knob .dial-highlight {
      opacity: 0;
      transition: all 300ms cubic-bezier(0.39, 0.575, 0.565, 1);
    }
    .fl-studio-envelope__knob:hover .dial, .fl-studio-envelope__knob.drag-active .dial {
      -webkit-transform: scale(0.9);
              transform: scale(0.9);
      -webkit-filter: brightness(10.2);
              filter: brightness(10.2);
      transition: all 300ms cubic-bezier(0.39, 0.575, 0.565, 1);
    }
    .fl-studio-envelope__knob:hover .dial-highlight, .fl-studio-envelope__knob.drag-active .dial-highlight {
      opacity: 0.05;
    }
    .fl-studio-envelope__knob .focus-indicator {
      opacity: 0;
      transition: all 300ms cubic-bezier(0.39, 0.575, 0.565, 1);
    }
    .fl-studio-envelope__knob.focus-active .focus-indicator {
      opacity: 0.8;
    }
    
    .knob-input {
      position: relative;
    }
    
    .knob-input__visual {
      pointer-events: none;
      width: 100%;
      height: 100%;
    }
    
    .knob-input__input {
      cursor: -webkit-grab;
      cursor: grab;
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      -webkit-transform: rotate(-90deg);
              transform: rotate(-90deg);
    }
    
    body.knob-input__drag-active, body.knob-input__drag-active * {
      cursor: -webkit-grabbing !important;
      cursor: grabbing !important;
    }
    </style></head><body class="">
    
    <svg class="defs">
      <defs>
        <radialGradient id="grad-dial-soft-shadow" cx="0.5" cy="0.5" r="0.5">
          <stop offset="85%" stop-color="#242a2e" stop-opacity="0.4"></stop>
          <stop offset="100%" stop-color="#242a2e" stop-opacity="0"></stop>
        </radialGradient>
        <linearGradient id="grad-dial-base" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#52595f"></stop>
          <stop offset="100%" stop-color="#2b3238"></stop>
        </linearGradient>
        <linearGradient id="grad-dial-highlight" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%" stop-color="#70777d" stop-opacity="1"></stop>
          <stop offset="40%" stop-color="#70777d" stop-opacity="0"></stop>
          <stop offset="55%" stop-color="#70777d" stop-opacity="0"></stop>
          <stop offset="100%" stop-color="#70777d" stop-opacity="0.3"></stop>
        </linearGradient>
        <filter id="glow">
          <feGaussianBlur in="SourceGraphic" result="blur" stdDeviation="2"></feGaussianBlur>
          <feComposite in="blur" in2="SourceGraphic" operator="over"></feComposite>
        </filter>
      </defs>
    </svg>

    
         
       
        <div class="knob-input fl-studio-envelope__knob envelope-knob" id="knob_1">
            <svg class="knob-input__visual" viewBox="0 0 40 40">
              <circle class="focus-indicator" cx="20" cy="20" r="18" fill="#4eccff" filter="url(#glow)"></circle>
              <circle class="indicator-ring-bg" cx="20" cy="20" r="18" fill="#353b3f" stroke="#23292d"></circle>
              <path class="indicator-ring" d="M20,20l0,17.5A-17.5,17.5,0,0,1,20,37.5Z" fill="#4eccff"></path>
              <g class="dial">
                <circle cx="20" cy="20" r="16" fill="url(#grad-dial-soft-shadow)"></circle>
                <ellipse cx="20" cy="22" rx="14" ry="14.5" fill="#242a2e" opacity="0.15"></ellipse>
                <circle cx="20" cy="20" r="14" fill="url(#grad-dial-base)" stroke="#242a2e" stroke-width="1.5"></circle>
                <circle cx="20" cy="20" r="13" fill="transparent" stroke="url(#grad-dial-highlight)" stroke-width="1.5"></circle>
                <circle class="dial-highlight" cx="20" cy="20" r="14" fill="#ffffff"></circle>
                <circle class="indicator-dot" cx="20" cy="30" r="1.5" fill="#4eccff" style="transform-origin: 20px 20px; transform: rotate(0deg);"></circle>
              </g>
            </svg>
          <input type="range" step="any" min="0" max="100" class="knob-input__input" id="knob1">
        </div>          
        
        <div class="knob-input fl-studio-envelope__knob envelope-knob" id="knob_2">
                <svg class="knob-input__visual" viewBox="0 0 40 40">
                  <circle class="focus-indicator" cx="20" cy="20" r="18" fill="#4eccff" filter="url(#glow)"></circle>
                  <circle class="indicator-ring-bg" cx="20" cy="20" r="18" fill="#353b3f" stroke="#23292d"></circle>
                  
                  
                  <defs>  
                      <mask id="mask2" x="0" y="0" width="100" height="100" >        
                        <g fill="white" stroke="none" transform="translate(10.500000,60.500000) scale(0.070000,-0.070000)">
                          <path d="M320 673 c0 -24 4 -28 30 -28 26 0 30 4 30 28 0 23 -4 27 -30 27 -26 0 -30 -4 -30 -27z"/>
                          <path d="M207 674 c-24 -13 -26 -17 -16 -37 7 -12 13 -23 14 -25 4 -5 55 21 55 27 -1 17 -13 51 -19 51 -3 -1 -18 -8 -34 -16z"/>
                           <path d="M439 664 c-5 -15 -8 -27 -7 -28 2 -1 15 -7 30 -14 24 -10 29 -9 38 8 15 28 13 36 -15 48 -34 16 -34 16 -46 -14z"/>
                                      <path d="M95 600 c-18 -20 -18 -21 3 -43 l22 -21 22 21 c21 22 21 23 3 43 -10 11 -21 20 -25 20 -4 0 -15 -9 -25 -20z"/>
                                      <path d="M555 600 c-18 -20 -18 -21 3 -43 l22 -21 22 21 c21 22 21 23 3 43 -10 11 -21 20 -25 20 -4 0 -15 -9 -25 -20z"/>
                                      <path d="M635 508 c-11 -6 -21 -12 -23 -13 -1 -1 3 -15 10 -29 10 -23 16 -26 37 -21 14 4 27 8 29 10 3 3 -26 65 -31 65 -1 0 -11 -6 -22 -12z"/>
                                      <path d="M21 483 c-13 -28 -8 -37 24 -47 16 -5 23 0 32 24 10 26 9 32 -7 40 -28 15 -36 12 -49 -17z"/>
                                      <path d="M0 350 c0 -26 4 -30 28 -30 23 0 27 4 27 30 0 26 -4 30 -27 30 -24 0 -28 -4 -28 -30z"/>
                                      <path d="M645 350 c0 -26 4 -30 28 -30 23 0 27 4 27 30 0 26 -4 30 -27 30 -24 0 -28 -4 -28 -30z"/>
                                      <path d="M623 240 c-10 -26 -9 -32 7 -40 28 -15 36 -12 49 17 13 28 8 37 -24 47 -16 5 -23 0 -32 -24z"/>
                                      <path d="M28 253 c-22 -5 -22 -7 -3 -44 14 -26 18 -28 38 -18 12 7 23 13 25 14 1 1 -3 14 -9 29 -12 26 -18 28 -51 19z"/>
                                      <path d="M95 140 c-18 -20 -18 -21 3 -43 l22 -21 22 21 c21 22 21 23 3 43 -10 11 -21 20 -25 20 -4 0 -15 -9 -25 -20z"/>
                                      <path d="M555 140 c-18 -20 -18 -21 3 -43 l22 -21 22 21 c21 22 21 23 3 43 -10 11 -21 20 -25 20 -4 0 -15 -9 -25 -20z"/>
                                      <path d="M200 70 c-15 -28 -12 -36 17 -49 28 -13 37 -8 47 24 5 16 0 23 -24 32 -26 10 -32 9 -40 -7z"/>
                                      <path d="M462 78 c-19 -9 -22 -17 -17 -37 9 -35 9 -35 44 -17 28 15 29 19 19 41 -13 28 -14 28 -46 13z"/>
                                      <path d="M320 28 c0 -24 4 -28 30 -28 26 0 30 4 30 28 0 23 -4 27 -30 27 -26 0 -30 -4 -30 -27z"/>
                                  </g>
                      </mask>
                      
                    </defs>

                    <path class="indicator-ring" d="M20,20l0,17.5A-17.5,17.5,0,0,1,20,37.5Z" fill="#4eccff" style="stroke: none; mask: url(#mask2)"></path>

                  <g class="dial">
                    <circle cx="20" cy="20" r="14" fill="url(#grad-dial-soft-shadow)"></circle>
                    <ellipse cx="20" cy="22" rx="12" ry="14.5" fill="#242a2e" opacity="0.15"></ellipse>
                    <circle cx="20" cy="20" r="12" fill="url(#grad-dial-base)" stroke="#242a2e" stroke-width="1.5"></circle>
                    <circle cx="20" cy="20" r="11" fill="transparent" stroke="url(#grad-dial-highlight)" stroke-width="1.5"></circle>
                    <circle class="dial-highlight" cx="20" cy="20" r="14" fill="#ffffff"></circle>
                    <circle class="indicator-dot" cx="15" cy="25" r="3" fill="#4eccff" style="transform-origin: 20px 20px; transform: rotate(0deg);"></circle>
                  </g>
                </svg>
              <input type="range" step="any" min="0" max="100" class="knob-input__input" id="knob2">
            </div>    
          
    
   <script>
   

   "use strict";"object"!=typeof window.CP&&(window.CP={}),window.CP.PenTimer={programNoLongerBeingMonitored:!1,timeOfFirstCallToShouldStopLoop:0,_loopExits:{},_loopTimers:{},START_MONITORING_AFTER:2e3,STOP_ALL_MONITORING_TIMEOUT:5e3,MAX_TIME_IN_LOOP_WO_EXIT:2200,exitedLoop:function(o){this._loopExits[o]=!0},shouldStopLoop:function(o){if(this.programKilledSoStopMonitoring)return!0;if(this.programNoLongerBeingMonitored)return!1;if(this._loopExits[o])return!1;var t=this._getTime();if(0===this.timeOfFirstCallToShouldStopLoop)return this.timeOfFirstCallToShouldStopLoop=t,!1;var i=t-this.timeOfFirstCallToShouldStopLoop;if(i<this.START_MONITORING_AFTER)return!1;if(i>this.STOP_ALL_MONITORING_TIMEOUT)return this.programNoLongerBeingMonitored=!0,!1;try{this._checkOnInfiniteLoop(o,t)}catch(e){return this._sendErrorMessageToEditor(),this.programKilledSoStopMonitoring=!0,!0}return!1},_sendErrorMessageToEditor:function(){try{if(this._shouldPostMessage()){var o={action:"infinite-loop",line:this._findAroundLineNumber()};parent.postMessage(o,"*")}else this._throwAnErrorToStopPen()}catch(t){this._throwAnErrorToStopPen()}},_shouldPostMessage:function(){return document.location.href.match(/boomerang/)},_throwAnErrorToStopPen:function(){throw"We found an infinite loop in your Pen. We've stopped the Pen from running. Please correct it or contact support@codepen.io."},_findAroundLineNumber:function(){var o=new Error,t=0;if(o.stack){var i=o.stack.match(/boomerang\S+:(\d+):\d+/);i&&(t=i[1])}return t},_checkOnInfiniteLoop:function(o,t){if(!this._loopTimers[o])return this._loopTimers[o]=t,!1;if(t-this._loopTimers[o]>this.MAX_TIME_IN_LOOP_WO_EXIT)throw"Infinite Loop found on loop: "+o},_getTime:function(){return+new Date}},window.CP.shouldStopExecution=function(o){var t=window.CP.PenTimer.shouldStopLoop(o);return!0===t&&console.warn("[CodePen]: An infinite loop (or a loop taking too long) was detected, so we stopped its execution. Sorry!"),t},window.CP.exitedLoop=function(o){window.CP.PenTimer.exitedLoop(o)};




    
    // KnobInput class
    
    class KnobInput {

      constructor(containerElement, options) {
        if (!options) {
          options = {};
        }
    
        // settings
        var step = options.step || 'any';
        var min = typeof options.min === 'number' ? options.min : 0;
        var max = typeof options.max === 'number' ? options.max : 1;
        this.initial = typeof options.initial === 'number' ? options.initial : 0.5 * (min + max);
        this.visualElementClass = options.visualElementClass || 'knob-input__visual';
        this.dragResistance = typeof options.dragResistance === 'number' ? options.dragResistance : 300;
        this.dragResistance /= max - min;
        this.wheelResistance = typeof options.wheelResistance === 'number' ? options.wheelResistance : 4000;
        this.wheelResistance /= max - min;
        this.setupVisualContext = typeof options.visualContext === 'function' ? options.visualContext : KnobInput.setupRotationContext(0, 360);
        this.updateVisuals = typeof options.updateVisuals === 'function' ? options.updateVisuals : KnobInput.rotationUpdateFunction;
    
        // setup input
        var rangeInput = document.createElement('input');
        rangeInput.type = 'range';
        rangeInput.step = step;
        rangeInput.min = min;
        rangeInput.max = max;
        rangeInput.value = this.initial;
        containerElement.appendChild(rangeInput);
    
        // elements
        this._container = containerElement;
        this._container.classList.add('knob-input');
        this._input = rangeInput;
        this._input.classList.add('knob-input__input');
        this._visualElement = this._container.querySelector(`.${this.visualElementClass}`);
        this._visualElement.classList.add('knob-input__visual');
    
        // visual context
        this._visualContext = { element: this._visualElement };
        this.setupVisualContext.apply(this._visualContext);
        this.updateVisuals = this.updateVisuals.bind(this._visualContext);
    
        // internals
        this._activeDrag = false;
    
        // define event listeners
        // have to store bound versions of handlers so they can be removed later
        this._handlers = {
          inputChange: this.handleInputChange.bind(this),
          touchStart: this.handleTouchStart.bind(this),
          touchMove: this.handleTouchMove.bind(this),
          touchEnd: this.handleTouchEnd.bind(this),
          touchCancel: this.handleTouchCancel.bind(this),
          mouseDown: this.handleMouseDown.bind(this),
          mouseMove: this.handleMouseMove.bind(this),
          mouseUp: this.handleMouseUp.bind(this),
          mouseWheel: this.handleMouseWheel.bind(this),
          doubleClick: this.handleDoubleClick.bind(this),
          focus: this.handleFocus.bind(this),
          blur: this.handleBlur.bind(this) };
    
        // add listeners
        this._input.addEventListener('change', this._handlers.inputChange);
        this._input.addEventListener('touchstart', this._handlers.touchStart);
        this._input.addEventListener('mousedown', this._handlers.mouseDown);
        this._input.addEventListener('wheel', this._handlers.mouseWheel);
        this._input.addEventListener('dblclick', this._handlers.doubleClick);
        this._input.addEventListener('focus', this._handlers.focus);
        this._input.addEventListener('blur', this._handlers.blur);
        // init
        this.updateToInputValue();
      }
    
      static setupRotationContext(minRotation, maxRotation) {
        return function () {
          this.minRotation = minRotation;
          this.maxRotation = maxRotation;
        };
      }
    
      static rotationUpdateFunction(norm) {
        this.element.style[transformProp] = `rotate(${this.maxRotation * norm - this.minRotation * (norm - 1)}deg)`;
      }
    
      // handlers
      handleInputChange(evt) {
        // console.log('input change');
        this.updateToInputValue();
      }
    
      handleTouchStart(evt) {
        // console.log('touch start');
        this.clearDrag();
        evt.preventDefault();
        var touch = evt.changedTouches.item(evt.changedTouches.length - 1);
        this._activeDrag = touch.identifier;
        this.startDrag(touch.clientY);
        // drag update/end listeners
        document.body.addEventListener('touchmove', this._handlers.touchMove);
        document.body.addEventListener('touchend', this._handlers.touchEnd);
        document.body.addEventListener('touchcancel', this._handlers.touchCancel);
      }
    
      handleTouchMove(evt) {
        // console.log('touch move');
        var activeTouch = this.findActiveTouch(evt.changedTouches);
        if (activeTouch) {
          this.updateDrag(activeTouch.clientY);
        } else if (!this.findActiveTouch(evt.touches)) {
          this.clearDrag();
        }
      }
    
      handleTouchEnd(evt) {
        // console.log('touch end');
        var activeTouch = this.findActiveTouch(evt.changedTouches);
        if (activeTouch) {
          this.finalizeDrag(activeTouch.clientY);
        }
      }
    
      handleTouchCancel(evt) {
        // console.log('touch cancel');
        if (this.findActiveTouch(evt.changedTouches)) {
          this.clearDrag();
        }
      }
    
      handleMouseDown(evt) {
        // console.log('mouse down');
        this.clearDrag();
        evt.preventDefault();
        this._activeDrag = true;
        this.startDrag(evt.clientY);
        // drag update/end listeners
        document.body.addEventListener('mousemove', this._handlers.mouseMove);
        document.body.addEventListener('mouseup', this._handlers.mouseUp);
      }
    
      handleMouseMove(evt) {
        // console.log('mouse move');
        if (evt.buttons & 1) {
          this.updateDrag(evt.clientY);
        } else {
          this.finalizeDrag(evt.clientY);
        }
      }
    
      handleMouseUp(evt) {
        // console.log('mouse up');
        this.finalizeDrag(evt.clientY);
      }
    
      handleMouseWheel(evt) {
        // console.log('mouse wheel');
        this._input.focus();
        this.clearDrag();
        this._prevValue = parseFloat(this._input.value);
        this.updateFromDrag(evt.deltaY, this.wheelResistance);
      }
    
      handleDoubleClick(evt) {
        // console.log('double click');
        this.clearDrag();
        this._input.value = this.initial;
        this.updateToInputValue();
      }
    
      handleFocus(evt) {
        // console.log('focus on');
        this._container.classList.add('focus-active');
      }
    
      handleBlur(evt) {
        // console.log('focus off');
        this._container.classList.remove('focus-active');
      }
    
      // dragging
      startDrag(yPosition) {
        this._dragStartPosition = yPosition;
        this._prevValue = parseFloat(this._input.value);
    
        this._input.focus();
        document.body.classList.add('knob-input__drag-active');
        this._container.classList.add('drag-active');
      }
    
      updateDrag(yPosition) {
        var diff = yPosition - this._dragStartPosition;
        this.updateFromDrag(diff, this.dragResistance);
        this._input.dispatchEvent(new InputEvent('change'));
      }
    
      finalizeDrag(yPosition) {
        var diff = yPosition - this._dragStartPosition;
        this.updateFromDrag(diff, this.dragResistance);
        this.clearDrag();
        this._input.dispatchEvent(new InputEvent('change'));
      }
    
      clearDrag() {
        document.body.classList.remove('knob-input__drag-active');
        this._container.classList.remove('drag-active');
        this._activeDrag = false;
        this._input.dispatchEvent(new InputEvent('change'));
        // clean up event listeners
        document.body.removeEventListener('mousemove', this._handlers.mouseMove);
        document.body.removeEventListener('mouseup', this._handlers.mouseUp);
        document.body.removeEventListener('touchmove', this._handlers.touchMove);
        document.body.removeEventListener('touchend', this._handlers.touchEnd);
        document.body.removeEventListener('touchcancel', this._handlers.touchCancel);
      }
    
      updateToInputValue() {
        var normVal = this.normalizeValue(parseFloat(this._input.value));
        this.updateVisuals(normVal);
      }
    
      updateFromDrag(dragAmount, resistance) {
        var newVal = this.clampValue(this._prevValue - dragAmount / resistance);
        this._input.value = newVal;
        this.updateVisuals(this.normalizeValue(newVal));
      }
    
      // utils
      clampValue(val) {
        var min = parseFloat(this._input.min);
        var max = parseFloat(this._input.max);
        return Math.min(Math.max(val, min), max);
      }
    
      normalizeValue(val) {
        var min = parseFloat(this._input.min);
        var max = parseFloat(this._input.max);
        return (val - min) / (max - min);
      }
    
      findActiveTouch(touchList) {
        var i, len, touch;
        for (i = 0, len = touchList.length; i < len; i++) {if (window.CP.shouldStopExecution(0)) break;
          if (this._activeDrag === touchList.item(i).identifier)
          return touchList.item(i);}window.CP.exitedLoop(0);
        return null;
      }
    
      // public passthrough methods
      addEventListener() {this._input.addEventListener.apply(this._input, arguments);}
      removeEventListener() {this._input.removeEventListener.apply(this._input, arguments);}
      focus() {this._input.focus.apply(this._input, arguments);}
      blur() {this._input.blur.apply(this._input, arguments);}
    
      // getters/setters
      get value() {
        return parseFloat(this._input.value);
      }
      set value(val) {
        this._input.value = val;
        this.updateToInputValue();
        this._input.dispatchEvent(new Event('change'));
      }}
    
    
    // Utils
    
    function getSupportedPropertyName(properties) {
      for (var i = 0; i < properties.length; i++) {if (window.CP.shouldStopExecution(1)) break;
        if (typeof document.body.style[properties[i]] !== 'undefined')
        return properties[i];}window.CP.exitedLoop(1);
      return null;
    }
    
    function getTransformProperty() {
      return getSupportedPropertyName([
      'transform', 'msTransform', 'webkitTransform', 'mozTransform', 'oTransform']);    
    }
    
      

    // Demo Setup - Knobs       
    var transformProp = getTransformProperty();    
    var envelopeKnobStartPositions = [90];
    var envelopeKnobs = [...document.querySelectorAll('.fl-studio-envelope__knob.envelope-knob')];
    var envelopeKnobs = envelopeKnobs.map((el, idx) => new KnobInput(el, {
      visualContext: function () {
        this.indicatorRing = this.element.querySelector('.indicator-ring');
        var ringStyle = getComputedStyle(this.element.querySelector('.indicator-ring-bg'));
        this.r = parseFloat(ringStyle.r) - parseFloat(ringStyle.strokeWidth) / 2;
        this.indicatorDot = this.element.querySelector('.indicator-dot');
        this.indicatorDot.style[`${transformProp}Origin`] = '20px 20px';
      },
      updateVisuals: function (norm) {
        var theta = Math.PI * 2 * norm + 0.5 * Math.PI;
        var endX = this.r * Math.cos(theta) + 20;
        var endY = this.r * Math.sin(theta) + 20;
        // using 2 arcs rather than flags since one arc collapses if it gets near 360deg
        this.indicatorRing.setAttribute('d', `M20,20l0,${this.r}${norm > 0.5 ? `A${this.r},${this.r},0,0,1,20,${20 - this.r}` : ''}A-${this.r},${this.r},0,0,1,${endX},${endY}Z`);
        this.indicatorDot.style[transformProp] = `rotate(${360 * norm}deg)`;
      },
      min: 0,
      max: 100,
      initial: envelopeKnobStartPositions[idx] }));
    
    
    
    
    function colorKnob(nr, color) {
      var transformProp = getTransformProperty();    
      var envelopeKnobStartPositions = [50];
      var envelopeKnobs = [...document.querySelectorAll('#knob_'+nr)];          
      // CHANGE COLOR DOT
      envelopeKnobs[0].children[0].children[3].children[5].attributes[4].nodeValue = color;
      envelopeKnobs[0].children[0].children[3].children[5].attributes[4].textContent = color;
      envelopeKnobs[0].children[0].children[3].children[5].attributes[4].value = color;
      // CHANGE COLOR RING
      envelopeKnobs[0].children[0].children[2].attributes[2].nodeValue = color;
      envelopeKnobs[0].children[0].children[2].attributes[2].textContent = color;
      envelopeKnobs[0].children[0].children[2].attributes[2].value = color;
    }

    
    function setNew(nr) {
        var transformProp = getTransformProperty();    
        var envelopeKnobStartPositions = [50];
        var envelopeKnobs = [...document.querySelectorAll('#knob_'+nr)];

        
        colorKnob(1, '#DDD');


        var envelopeKnobs = envelopeKnobs.map((el, idx) => new KnobInput(el, {
        visualContext: function () {
            this.indicatorRing = this.element.querySelector('.indicator-ring');
            var ringStyle = getComputedStyle(this.element.querySelector('.indicator-ring-bg'));
            this.r = parseFloat(ringStyle.r) - parseFloat(ringStyle.strokeWidth) / 2;
            this.indicatorDot = this.element.querySelector('.indicator-dot');
            this.indicatorDot.style[`${transformProp}Origin`] = '20px 20px';
        },
        updateVisuals: function (norm) {
            var theta = Math.PI * 2 * norm + 0.5 * Math.PI;
            var endX = this.r * Math.cos(theta) + 20;
            var endY = this.r * Math.sin(theta) + 20;
            // using 2 arcs rather than flags since one arc collapses if it gets near 360deg
            this.indicatorRing.setAttribute('d', `M20,20l0,${this.r}${norm > 0.5 ? `A${this.r},${this.r},0,0,1,20,${20 - this.r}` : ''}A-${this.r},${this.r},0,0,1,${endX},${endY}Z`);
            this.indicatorDot.style[transformProp] = `rotate(${360 * norm}deg)`;
        },
        min: 0,
        max: 100,
        initial: envelopeKnobStartPositions[idx] }));
        }
    

    </script>

    <div id="jjj" onclick="setNew(1);">gggggg</div>

    <div style="background-color: #FFF; height: 20px; width:40px; ">

    </div>

    
    </body></html>